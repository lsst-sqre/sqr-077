:tocdepth: 1

Abstract
========

SQuaRE is currently generating Python API documentation using Sphinx plus sphinx-automodapi_ and autodoc_pydantic_.
This mostly works, but exposes a few bugs and imperfections in the Sphinx extension stack.
This tech note discusses the goals for API documentation, current shortcomings, and possible alternatives.

.. _sphinx-automodapi: https://sphinx-automodapi.readthedocs.io/en/latest/
.. _autodoc_pydantic: https://autodoc-pydantic.readthedocs.io/en/stable/

Requirements
============

SQuaRE generates API documentation for two types of packages: library packages we upload to PyPI, and some web applications where API documentation may be helpful for further development.
Of those cases, API documentation for libraries is more important.

We have the following requirements for API documentation:

- Documentation should be generated from docstrings, rather than having to be written separately.

- Documentable objects inside a module should be discovered automatically.
  We should not have to update a list of objects to document when we add new classes, functions, constants, etc.
  (Apart from the tedium, it's also very easy to forget to do.)

- Not all modules should be forced to be included in the documentation.
  FastAPI route handlers are generally pointless to include in API documentation (they have no useful API), and SQLAlchemy schemas usually don't have useful autogenerated documentation.
  We want to be able to pick and choose by module whether it is included in the API documentation.

- The generated documentation should be reasonably easy to navigate: broken into separate pages in some reasonable way, with a summary of documented objects and links to the full documentation.

- Pydantic models should be documented properly with their fields, since we use Pydantic heavily.

Current issues
==============

The current approach using sphinx-automodapi has several known drawbacks.

Missing content
---------------

- sphinx-automodapi doesn't document methods and attributes for exceptions.
  Since we use rich structured exceptions for FastAPI error generation and Slack error reporting, this means substantial API documentation is missing.
  It's possible to work around this by overriding the template used by sphinx-automodapi for exception objects, although the result is not quite right.
  There is no way to generate an accurate attribute or method summary before the detailed documentation.

- Exceptions in our code bases often use inheritance heavily so that code can catch the parent exception.
  Each child exception has its own docstring to explain the specific meaning of that exception.
  Unfortunately, this breaks documentation of constructor arguments, since the docstring overrides the parent class docstring and thus its ``Parameters`` section.
  (It may be possible to work around this by documenting the parameters in a separate docstring for the ``__init__`` method.
  We haven't yet experimented with this.)

- Sphinx normally can resolve bare class references in method types and corresponding docstrings (such as the docstring for the return value) using the imports of the module in which the class occurs.
  Unfortunately, this doesn't work with ``:inherited-members:``.
  When the documentation of the inherited member has bare class references that would be resolved by the local imports of the module in which the source is located, they are shown as unresolved in the generated documentation and create Sphinx warnings.

- dataclasses are not recognized as such (ideally, they would receive special support similar to that for Pydantic models with autodoc_pydantic).
  The docstrings for their attributes are recognized and picked up by the attribute summary and documentation, but they're not associated with the constructor parameters.
  The constructor should either be suppressed or should use the first lines of the attribute docstrings.
  This can be worked around by duplicating the attribute docstrings in a ``Parameters`` section of the class docstring, but this is tedious.

Unwanted content
----------------

- The core Sphinx autodoc extension supports an exclusion list with the ``:inherited-members`` attribute to exclude inherited members from some base classes.
  Unfortunately, sphinx-automodapi doesn't support the exclusion list, only binary presence of ``:inherited-members:`` or its absence.
  This means there's no way to exclude inherited members from base classes that are not useful to document.

Awkward usage
-------------

- sphinx-automodapi doesn't fully integrate with autodoc_pydantic, which means there's no way to pass ``:inherited-members:``.
  One has to instead override the template used for Pydantic classes.
  It also doesn't generate a summary for Pydantic models, which would be useful for models that have normal instance or class methods.

- sphinx-automodapi generates stub files for every documented object, but doesn't remove them when they become obsolete, resulting in confusing Sphinx errors.
  This can be worked around by deleting all of the stub files before recreating the documentation.

- The return type of a function or method has to be reiterated in the docstring to document the return value.
  This is an artifact of using the NumPy documentation style.
  If we were using the native Sphinx documentation style, sphinx-autodoc-typehints_ would add the ``:rtype:`` directive automatically and we could write only a ``:returns:`` directive.

.. _sphinx-autodoc-typehints: https://pypi.org/project/sphinx-autodoc-typehints/

Formatting issues
-----------------

- Instance and class methods are sorted together in generated method documentation.
  Good Python practice is to list the class methods first, followed by the instance methods.

- Method parameters without detailed documentation (which happens most often with inherited constructors) show the parameter and type and then a trailing em-dash with nothing after it.
  Ideally, this dash should be suppressed if there is no documentation.

- Every documented object gets its own separate HTML file.
  In some cases, such as classes, this probably makes sense, but it's awkward for functions and undesirable for constants or type variables.

- The generated module inheritance diagrams don't support dark mode.

Support issues
--------------

- sphinx-automodapi is documented as not really being supported or actively developed, only changed as required for astropy's internal uses.
  Meanwhile, autodoc and autosummary have received considerable further development, but don't approach the problem in quite the same way.

Possible improvements
=====================

We have briefly explored a few alternative approaches to fix some of these issues.
None of these have yet been explored in depth or turned into a concrete plan.

Improve sphinx-automodapi
-------------------------

Some of these issues could be addressed in sphinx-automodapi with a moderate amount of work:

- It's reasonably straightforward to add support for exceptions with similar method and attribute documentation by adding a template for exceptions that's roughly the same as classes.

- Similarly, it's fairly easy to add Pydantic model support by adding a new template, although generating a reasonable summary of methods is harder since Pydantic models should normally include inherited methods but should not include methods inherited from ``pydantic.BaseModel``.

- Adding support for exclusion lists, similar to what the core autodoc extension supports, is presumably possible by copying the code from autodoc, although the existing code is more complicated.

However, this is somewhat unappealing given the largely unmaintained state of the module.
Its documentation warns that pull requests may not be reviewed in a timely fashion, for instance.

This is also not where the effort and energy in Python API documentation is currently going.
The autodoc and autosummary extensions are a core part of Sphinx and are gaining new features and getting more active attention.
sphinx-automodapi now largely duplicates functionality provided by other extensions, and it's not clear that both should continue to exist.

Switch to autodoc and autosummary
---------------------------------

It's appealing to adopt the Sphinx core extensions instead of using a third-party extension that isn't well-maintained.
One possible configuration would be to change the top-level API page to use autosummary with the ``:members:`` directives.
The content is a list of all of the modules that should be included in the documentation.
This will recursively generate documentation for the members of every module, with summaries.

This mostly works, but an experiment with Gafaelfawr_ uncovered a few issues.

.. _Gafaelfawr: https://gafaelfawr.lsst.io/

- The page structure is by module rather than by documented object.
  This is arguably a feature, but the top-level structure is only a list of modules rather than the summary of the contents of each module.
  Instead, the summary is put at the start of each documented object, which makes it much less useful.

- Any submodules of a module are automatically included, so there's no way to document a module and not the modules beneath it.
  This most obviously affects the top-level module of the library or application, which cannot be included in the documentation without including every module in the library or application.

- Using one ``autosummary`` directive at the top level means there's no way to pass configuration down to specific modules or objects.
  Specifically, this means that there's no way to selectively set ``:inherited-members:``.
  This may not be a serious problem, although it means the exclusion list of parent modules has to be maintained globally.

- The summary of modules that include Pydantic modules is wrong.
  It only includes the members of that module that are not Pydantic models.

- Inheritance diagrams are not included by default the way that they are with sphinx-automodapi.
  This probably just requires configuring the core inheritance diagram extension.

autodoc and autosummary do not fix the problems with inherited member documentation not resolving Python symbols properly, or with not inheriting docstrings for inherited constructor arguments.
It does work better with Pydantic, but doesn't have any better support for dataclasses.

Changing the docstring format
-----------------------------

Currently, the standard for all Rubin projects is to use the NumPy documentation format.
For newer projects, we use the core Napoleon extension to format those docstrings for Sphinx consumption.

While this mostly works well, particularly combined with sphinx-autodoc-typehints, it does add significant complexity to the documentation rendering process.
Sphinx has to analyze the mini-format used for the docstring, convert that to standard Sphinx reStructuredText directives, and then reprocess it with Sphinx.
It also causes a few minor problems, such as having to repeat the return type in the description of the return value due to the requirements of the NumPy documentation format.
There are some directives that have no NumPy equivalent, such as ``:meta private:`` and ``:meta public:``.

There is some appeal to switching to straight Sphinx markup in docstrings.
This requires less complexity in the documentation stack and has more straightforward behavior.
It would also avoid the rare but confusing bugs where the translation between the NumPy format to Sphinx fails or generates syntactically invalid reStructuredText.
Also, while there is no true standardization across Python, there does seem to be slightly more use of native reStructuredText than the other docstring formats (Google and NumPy) outside of the numpy and astropy worlds.

One drawback, in addition to the conversion work required, is that native reStructuredText docstrings are not quite as human-readable.
It also may not offer sufficient benefits to be worth the effort (and departure from practices elsewhere in Rubin, since it's unlikely other teams would change at this point).
